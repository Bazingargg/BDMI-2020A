# WEEK_FOUR

快速排序：问题在于序列过度有序而每次都选择最后一个元素进行排序之时；实际上的快排有可能随机抽取元素对序列进行分割；平均情况下 O(nlogn) 但最差情况有可能达到 O(n^2) 基本就已经相当于选择排序；
$$
O(n^2)O(nlog(n))
$$
注意决策树，基于比较的排序方法 为什么是——这还是树比较平衡的情况下

快排的好处在于它可以原地排序！直接调换就可以了，但是归并排序似乎并不容易(涉及的交换会比较多)
$$
O(nlog(n))
$$
桶排序和基排序

当情况 (待排序的数字情况有限) 可以确定的时候，遍历一遍；值比较多的时候，空间消耗是不可接受的；

基排序：占用的空间可能更小(0-1000排序需要1000个桶====)

idea：从最低位开始进行一次桶排序，个位->十位->百位.....

当桶足够多时，桶排序的复杂度为  O(n) 关键在于设计合适的桶，参见后面进行排序的代码

一定需要注意多个桶进行排序时先排低位，再排高位，否则容易出现问题 (多次排序之后后面乱序)

有关搜索树、平衡树之类 应尤其注意删除根节点之后的上浮问题 (上浮元素必须大于所有左子树、小于右子树，因此是左子树最右边或者右子树最左边的元素)

其余的思路可以参考数据与算法；

第4周代码链接:

https://github.com/Zoutianjian/The_first_Try_git/blob/master/Week_4-Copy1.ipynb