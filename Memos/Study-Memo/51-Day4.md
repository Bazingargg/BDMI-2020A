# 学习小结
## 快速排序 quick sort
### 参考算法 Bogo sort
算法思想 ：随机排序数组，排好了就输出来 。
$$
期望排序次数：n!\\
每次排序都要检查:n\\
因此复杂度：O(n!*n)
$$
### quick sort
$$
T（n）=T(L)+T(r)+O(n)\\排序与中间比较\\
复杂度：O(nlog(n))；
最坏复杂度：O(n^2)
$$
算法思想：
1. 随机选择第一个数a。
2. 分为左右两半（大于a,或小于a）
3. 递归处理左右两边，继续分，直到排好。
## 有两两比较的排序均不能达到比O(nlogn)小
会有n!个分支（自由排队问题）
### 合并排序已经最优
## 桶排序 bucket sort
基本思路：按等级分类即可
复杂度：
$$
O((log_r(M)+1)*(n+r))\\
O(n*([log_n(M)]+1))
$$

使用条件：需要与位数的关系为非指数，规模要不太大

## 链表
#####  顺序查询太慢！
## 二分查找树
类似于快排法，所以以对数方式增加复杂度，比顺序查找好
创建思路：
1. 随机找中

2. 一直分两边

3. 递归

#####  利用红黑树减少层数？？

##### 排序或输出思路
######  利用中序递归找到最小的节点，然后依次递归输出回来
``` python
 def in_order_traverse(self, node):
        if node is not None:
            self.in_order_traverse(node.lchild)
            print(node.value)
            self.in_order_traverse(node.rchild)
```
##### 查找
##### 插入

##### 删除

